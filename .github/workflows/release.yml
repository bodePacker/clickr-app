# This workflow builds an Electron application for Windows, macOS, and Linux
# using electron-builder. It then uploads the build output for each OS
# as a separate zipped artifact.

name: Release Clickr App

on:
  push:
    tags: ['v*']

permissions:
  contents: write

jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        include:
          - os: ubuntu-latest
            zip-file: keybinder-linux.zip
          - os: macos-latest
            zip-file: keybinder-macos.zip
          - os: windows-latest
            zip-file: keybinder-windows.zip
      fail-fast: false

    runs-on: ${{ matrix.os }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Set up Node.js
      # This action sets up a Node.js environment for use in actions
      uses: actions/setup-node@v5
      with:
        node-version: '22' # Use a long-term support (LTS) version of Node.js

    - name: Cache npm
      uses: actions/cache@v4
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/package.json') }}


    - name: Download external artifacts from Keybinder
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        curl -L \
          -H "Authorization: token $GITHUB_TOKEN" \
          -H "Accept: application/octet-stream" \
          -o "${{ matrix.zip-file }}" \
          "https://github.com/clickrTeam/Keybinder/releases/latest/download/${{ matrix.zip-file }}"
      shell: bash

    - name: Unzip File
      run: |
        mkdir -p app/keybinder
        unzip ${{ matrix.zip-file }} -d app/keybinder
        
    - name: Verify directory structure
      run: |
        echo "Listing app directory:"
        ls -R app

    - name: Dependancies
      run: |
        cd app
        npm i
    - name: Build
      run: |
        cd app
        npm run build
    - name: Build OS
      shell: bash
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        cd app
        # OS-specific build commands
        if [ "${{ runner.os }}" == "Windows" ]; then
          npm run build:win
        elif [ "${{ runner.os }}" == "macOS" ]; then
          npm run build:mac
        elif [ "${{ runner.os }}" == "Linux" ]; then
          npm run build:linux
        else
          echo "Unsupported operating system: ${{ runner.os }}"
          exit 1
        fi


    - name: Read app metadata
      id: meta
      run: |
        # Read product name and version from app/package.json and export to env
        PRODUCT_NAME=$(node -p "require('./app/package.json').productName || require('./app/package.json').name")
        VERSION=$(node -p "require('./app/package.json').version")
        echo "PRODUCT_NAME=$PRODUCT_NAME" >> $GITHUB_ENV
        echo "VERSION=$VERSION" >> $GITHUB_ENV
      shell: bash

    - name: Locate generated installer
      id: find_installer
      run: |
        set -e
        # Look for a file in app/dist (or subdirs) that contains both product name and version
        product="$PRODUCT_NAME"
        version="$VERSION"
        base_dir="app/dist"
        if [ ! -d "$base_dir" ]; then
          echo "Directory $base_dir not found"
          exit 1
        fi
        match=$(find "$base_dir" -type f -iname "*${product}*${version}*" | head -n 1 || true)
        if [ -z "$match" ]; then
          # Try a looser match (either product or version)
          match=$(find "$base_dir" -type f \( -iname "*${product}*" -o -iname "*${version}*" \) | head -n 1 || true)
        fi
        if [ -z "$match" ]; then
          echo "No installer matching ${product} and ${version} found in $base_dir"
          exit 1
        fi
        echo "Found installer: $match"
        echo "installer=$match" >> $GITHUB_OUTPUT
      shell: bash

    - name: Upload single installer artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.os }}-installer
        path: ${{ steps.find_installer.outputs.installer }}

    - name: Configure AWS credentials for R2
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.CLOUDFLARE_R2_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.CLOUDFLARE_R2_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Upload installer to Cloudflare R2
      run: |
        # Get the installer file path and name
        INSTALLER_PATH="${{ steps.find_installer.outputs.installer }}"
        INSTALLER_NAME=$(basename "$INSTALLER_PATH")
        
        # Verify the installer file exists
        if [ ! -f "$INSTALLER_PATH" ]; then
          echo "Error: Installer file not found at $INSTALLER_PATH"
          exit 1
        fi
        
        # Get file size for logging
        FILE_SIZE=$(du -h "$INSTALLER_PATH" | cut -f1)
        echo "Found installer: $INSTALLER_NAME ($FILE_SIZE)"
        
        # Create simple filename based on OS
        SIMPLE_FILENAME=""
        if [ "${{ runner.os }}" == "Windows" ]; then
          SIMPLE_FILENAME="clickr-windows.exe"
        elif [ "${{ runner.os }}" == "macOS" ]; then
          SIMPLE_FILENAME="clickr-macos.dmg"
        elif [ "${{ runner.os }}" == "Linux" ]; then
          SIMPLE_FILENAME="clickr-linux.AppImage"
        fi
        
        # Upload to R2 with simple structure (always replaces the old file)
        echo "Uploading $SIMPLE_FILENAME to R2..."
        if aws s3 cp "$INSTALLER_PATH" "s3://${{ secrets.CLOUDFLARE_R2_BUCKET_NAME }}/${SIMPLE_FILENAME}" \
          --endpoint-url "https://e35a31a8c778c47d320a81d62a0869aa.r2.cloudflarestorage.com"; then
          echo "Successfully uploaded $SIMPLE_FILENAME (replaced previous version)"
        else
          echo "Failed to upload to R2"
          exit 1
        fi
        
        # Output download URL for reference
        echo "" 
        echo "Download URL: https://e35a31a8c778c47d320a81d62a0869aa.r2.cloudflarestorage.com/$SIMPLE_FILENAME"
      shell: bash